// Code generated by goagen v1.3.0, DO NOT EDIT.
//
// API "golang-foo": Application User Types
//
// Command:
// $ goagen
// --design=github.com/golang-starters/golang-rest-http/design
// --out=$(GOPATH)/src/github.com/golang-starters/golang-rest-http
// --version=v1.3.0

package app

import (
	"github.com/goadesign/goa"
	uuid "github.com/satori/go.uuid"
)

// dataKindUUID user type.
type dataKindUUID struct {
	// UUID of the object
	ID   *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Type *string    `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the dataKindUUID type instance.
func (ut *dataKindUUID) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	return
}

// Publicize creates DataKindUUID from dataKindUUID
func (ut *dataKindUUID) Publicize() *DataKindUUID {
	var pub DataKindUUID
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// DataKindUUID user type.
type DataKindUUID struct {
	// UUID of the object
	ID   uuid.UUID `form:"id" json:"id" xml:"id"`
	Type string    `form:"type" json:"type" xml:"type"`
}

// Validate validates the DataKindUUID type instance.
func (ut *DataKindUUID) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}

	return
}

// genericData user type.
type genericData struct {
	// UUID of the object
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Publicize creates GenericData from genericData
func (ut *genericData) Publicize() *GenericData {
	var pub GenericData
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = ut.Type
	}
	return &pub
}

// GenericData user type.
type GenericData struct {
	// UUID of the object
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// genericLinks user type.
type genericLinks struct {
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Publicize creates GenericLinks from genericLinks
func (ut *genericLinks) Publicize() *GenericLinks {
	var pub GenericLinks
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Related != nil {
		pub.Related = ut.Related
	}
	if ut.Self != nil {
		pub.Self = ut.Self
	}
	return &pub
}

// GenericLinks user type.
type GenericLinks struct {
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Error objects provide additional information about problems encountered while
// performing an operation. Error objects MUST be returned as an array keyed by errors in the
// top level of a JSON API document.
//
// See. also http://jsonapi.org/format/#error-objects.
type jSONAPIError struct {
	// an application-specific error code, expressed as a string value.
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// a human-readable explanation specific to this occurrence of the problem.
	// Like title, this field’s value can be localized.
	Detail *string `form:"detail,omitempty" json:"detail,omitempty" xml:"detail,omitempty"`
	// a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// a links object containing the following members:
	// * about: a link that leads to further details about this particular occurrence of the problem.
	Links map[string]*jSONAPILink `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// a meta object containing non-standard meta-information about the error
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// an object containing references to the source of the error,
	// optionally including any of the following members
	//
	// * pointer: a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. "/data" for a primary data object,
	//            or "/data/attributes/title" for a specific attribute].
	// * parameter: a string indicating which URI query parameter caused the error.
	Source map[string]interface{} `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// the HTTP status code applicable to this problem, expressed as a string value.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// a short, human-readable summary of the problem that SHOULD NOT
	// change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
}

// Validate validates the jSONAPIError type instance.
func (ut *jSONAPIError) Validate() (err error) {
	if ut.Detail == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "detail"))
	}
	return
}

// Publicize creates JSONAPIError from jSONAPIError
func (ut *jSONAPIError) Publicize() *JSONAPIError {
	var pub JSONAPIError
	if ut.Code != nil {
		pub.Code = ut.Code
	}
	if ut.Detail != nil {
		pub.Detail = *ut.Detail
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = make(map[string]*JSONAPILink, len(ut.Links))
		for k2, v2 := range ut.Links {
			pubk2 := k2
			var pubv2 *JSONAPILink
			if v2 != nil {
				pubv2 = v2.Publicize()
			}
			pub.Links[pubk2] = pubv2
		}
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Source != nil {
		pub.Source = ut.Source
	}
	if ut.Status != nil {
		pub.Status = ut.Status
	}
	if ut.Title != nil {
		pub.Title = ut.Title
	}
	return &pub
}

// Error objects provide additional information about problems encountered while
// performing an operation. Error objects MUST be returned as an array keyed by errors in the
// top level of a JSON API document.
//
// See. also http://jsonapi.org/format/#error-objects.
type JSONAPIError struct {
	// an application-specific error code, expressed as a string value.
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// a human-readable explanation specific to this occurrence of the problem.
	// Like title, this field’s value can be localized.
	Detail string `form:"detail" json:"detail" xml:"detail"`
	// a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// a links object containing the following members:
	// * about: a link that leads to further details about this particular occurrence of the problem.
	Links map[string]*JSONAPILink `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// a meta object containing non-standard meta-information about the error
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// an object containing references to the source of the error,
	// optionally including any of the following members
	//
	// * pointer: a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. "/data" for a primary data object,
	//            or "/data/attributes/title" for a specific attribute].
	// * parameter: a string indicating which URI query parameter caused the error.
	Source map[string]interface{} `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// the HTTP status code applicable to this problem, expressed as a string value.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// a short, human-readable summary of the problem that SHOULD NOT
	// change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
}

// Validate validates the JSONAPIError type instance.
func (ut *JSONAPIError) Validate() (err error) {
	if ut.Detail == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "detail"))
	}
	return
}

// See also http://jsonapi.org/format/#document-links.
type jSONAPILink struct {
	// a string containing the link's URL.
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// a meta object containing non-standard meta-information about the link.
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates JSONAPILink from jSONAPILink
func (ut *jSONAPILink) Publicize() *JSONAPILink {
	var pub JSONAPILink
	if ut.Href != nil {
		pub.Href = ut.Href
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// See also http://jsonapi.org/format/#document-links.
type JSONAPILink struct {
	// a string containing the link's URL.
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// a meta object containing non-standard meta-information about the link.
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// relationGeneric user type.
type relationGeneric struct {
	Data  *genericData           `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates RelationGeneric from relationGeneric
func (ut *relationGeneric) Publicize() *RelationGeneric {
	var pub RelationGeneric
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationGeneric user type.
type RelationGeneric struct {
	Data  *GenericData           `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// relationGenericList user type.
type relationGenericList struct {
	Data  []*genericData         `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates RelationGenericList from relationGenericList
func (ut *relationGenericList) Publicize() *RelationGenericList {
	var pub RelationGenericList
	if ut.Data != nil {
		pub.Data = make([]*GenericData, len(ut.Data))
		for i2, elem2 := range ut.Data {
			pub.Data[i2] = elem2.Publicize()
		}
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationGenericList user type.
type RelationGenericList struct {
	Data  []*GenericData         `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// relationKindUUID user type.
type relationKindUUID struct {
	Data  *dataKindUUID          `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Validate validates the relationKindUUID type instance.
func (ut *relationKindUUID) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates RelationKindUUID from relationKindUUID
func (ut *relationKindUUID) Publicize() *RelationKindUUID {
	var pub RelationKindUUID
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationKindUUID user type.
type RelationKindUUID struct {
	Data  *DataKindUUID          `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Validate validates the RelationKindUUID type instance.
func (ut *RelationKindUUID) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}
